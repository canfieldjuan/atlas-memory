"""
Track storage and event management.

Stores active tracks and detection events for API access
and WebSocket broadcasting.
"""

import asyncio
import logging
from collections import deque
from datetime import datetime
from typing import Callable, Optional

from ...core.models import (
    Track,
    TrackState,
    DetectionEvent,
    DetectionEventType,
)

logger = logging.getLogger("atlas.vision.tracking.store")


class TrackStore:
    """
    In-memory store for tracks and detection events.

    Maintains:
    - Active tracks per source
    - Recent detection events (ring buffer)
    - Event callbacks for real-time notifications
    """

    def __init__(self, max_events: int = 1000):
        """
        Initialize track store.

        Args:
            max_events: Maximum events to keep in history
        """
        self._active_tracks: dict[str, dict[int, Track]] = {}  # source_id -> track_id -> Track
        self._events: deque[DetectionEvent] = deque(maxlen=max_events)
        self._event_callbacks: list[Callable[[DetectionEvent], None]] = []
        self._lock = asyncio.Lock()

        logger.info("TrackStore initialized (max_events=%d)", max_events)

    async def update_tracks(self, source_id: str, tracks: list[Track]) -> list[DetectionEvent]:
        """
        Update tracks for a source and generate events.

        Args:
            source_id: Camera/source identifier
            tracks: Current tracks from detector

        Returns:
            List of events generated by this update
        """
        async with self._lock:
            events = []
            timestamp = datetime.utcnow()

            # Initialize source if needed
            if source_id not in self._active_tracks:
                self._active_tracks[source_id] = {}

            current_track_ids = {t.track_id for t in tracks}
            existing_track_ids = set(self._active_tracks[source_id].keys())

            # Find new tracks
            new_track_ids = current_track_ids - existing_track_ids
            for track in tracks:
                if track.track_id in new_track_ids:
                    event = DetectionEvent(
                        event_type=DetectionEventType.NEW_TRACK,
                        track_id=track.track_id,
                        class_name=track.class_name,
                        source_id=source_id,
                        timestamp=timestamp,
                        bbox=track.bbox,
                    )
                    events.append(event)
                    self._events.append(event)

            # Find lost tracks
            lost_track_ids = existing_track_ids - current_track_ids
            for track_id in lost_track_ids:
                old_track = self._active_tracks[source_id].get(track_id)
                if old_track and old_track.state != TrackState.LOST:
                    event = DetectionEvent(
                        event_type=DetectionEventType.TRACK_LOST,
                        track_id=track_id,
                        class_name=old_track.class_name,
                        source_id=source_id,
                        timestamp=timestamp,
                    )
                    events.append(event)
                    self._events.append(event)

            # Update track store
            self._active_tracks[source_id] = {t.track_id: t for t in tracks}

            # Notify callbacks
            for event in events:
                await self._notify_callbacks(event)

            return events

    async def _notify_callbacks(self, event: DetectionEvent) -> None:
        """Notify registered callbacks of new event."""
        for callback in self._event_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    await callback(event)
                else:
                    callback(event)
            except Exception as e:
                logger.warning("Event callback failed: %s", e)

    def register_callback(self, callback: Callable[[DetectionEvent], None]) -> None:
        """Register a callback for detection events."""
        self._event_callbacks.append(callback)

    def unregister_callback(self, callback: Callable[[DetectionEvent], None]) -> None:
        """Unregister an event callback."""
        if callback in self._event_callbacks:
            self._event_callbacks.remove(callback)

    def get_active_tracks(self, source_id: Optional[str] = None) -> list[Track]:
        """
        Get all active tracks.

        Args:
            source_id: Optional filter by source

        Returns:
            List of active tracks
        """
        tracks = []

        if source_id:
            if source_id in self._active_tracks:
                tracks.extend(self._active_tracks[source_id].values())
        else:
            for source_tracks in self._active_tracks.values():
                tracks.extend(source_tracks.values())

        # Filter out lost tracks
        return [t for t in tracks if t.state != TrackState.LOST]

    def get_all_tracks(self, source_id: Optional[str] = None) -> list[Track]:
        """
        Get all tracks including lost ones.

        Args:
            source_id: Optional filter by source

        Returns:
            List of all tracks
        """
        tracks = []

        if source_id:
            if source_id in self._active_tracks:
                tracks.extend(self._active_tracks[source_id].values())
        else:
            for source_tracks in self._active_tracks.values():
                tracks.extend(source_tracks.values())

        return tracks

    def get_track(self, track_id: int, source_id: Optional[str] = None) -> Optional[Track]:
        """
        Get a specific track by ID.

        Args:
            track_id: Track ID to find
            source_id: Optional source to search in

        Returns:
            Track if found
        """
        if source_id:
            return self._active_tracks.get(source_id, {}).get(track_id)

        for source_tracks in self._active_tracks.values():
            if track_id in source_tracks:
                return source_tracks[track_id]

        return None

    def get_events(
        self,
        since: Optional[datetime] = None,
        source_id: Optional[str] = None,
        event_type: Optional[DetectionEventType] = None,
        limit: int = 100,
    ) -> list[DetectionEvent]:
        """
        Get recent detection events.

        Args:
            since: Only events after this time
            source_id: Filter by source
            event_type: Filter by event type
            limit: Maximum events to return

        Returns:
            List of matching events (newest first)
        """
        events = list(self._events)
        events.reverse()  # Newest first

        # Apply filters
        if since:
            events = [e for e in events if e.timestamp > since]
        if source_id:
            events = [e for e in events if e.source_id == source_id]
        if event_type:
            events = [e for e in events if e.event_type == event_type]

        return events[:limit]

    def get_track_counts(self) -> dict[str, dict[str, int]]:
        """
        Get track counts by source and class.

        Returns:
            Dict of source_id -> class_name -> count
        """
        counts = {}

        for source_id, tracks in self._active_tracks.items():
            counts[source_id] = {}
            for track in tracks.values():
                if track.state != TrackState.LOST:
                    class_name = track.class_name
                    counts[source_id][class_name] = counts[source_id].get(class_name, 0) + 1

        return counts

    def clear(self, source_id: Optional[str] = None) -> None:
        """Clear tracks and events."""
        if source_id:
            if source_id in self._active_tracks:
                self._active_tracks[source_id].clear()
        else:
            self._active_tracks.clear()
            self._events.clear()


# Global store instance
_track_store: Optional[TrackStore] = None


def get_track_store() -> TrackStore:
    """Get or create the global track store."""
    global _track_store
    if _track_store is None:
        _track_store = TrackStore()
    return _track_store
